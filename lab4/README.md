# CVLabs
# CVLab 4
1.	Фильтрация изображения с помощью произвольного линейного фильтра (заданного пользователем) 3х3.
Разработайте программу, обеспечивающую загрузку изображения image0.jpg и применение линейного фильтра с вещественным ядром 3х3, заданным константой 
kernel = {-0.1, 0.2, -0.1,
                 0.2, 3.0, 0.2,
                -0.1, 0.2, -0.1};
Выполните отображение исходного и результирующего изображений.

При реализации используйте функцию 
filter2D (src, ddepth, kernel[, dst[, anchor[, delta[, borderType]]]]) -> dst
Параметры:
   src - входное изображение;.
   dst - целевое изображение того же размера, что и src.
  ddepth - задает глубину выходного изображения; обычно = -1 означает, что нужно использовать такую же глубину, как у входного
  kernel - ядро свертки (а точнее ядро корреляции); матрица чисел с пла-вающей запятой;
 anchor - определяет положение так называемого якорного пикселя. По умолчанию значение (–1, –1) означает, что якорь находится в центре ядра
 delta - необязательное значение, добавляемое к отфильтрованным пиксе-лям перед их сохранением в dst.
  borderType - определяет поведение на краях изображения. default = BORDER_DEFAULT= gfedcb|abcdefgh|gfedcba

2.	Фильтрация изображения с помощью линейного арифметического взве-шенного усредняющего фильтра (ФНЧ) 5х5, заданного пользователем.
Постройте арифметический взвешенный усредняющий фильтр (ФНЧ) с маской 5х5. В качестве меры расстояния используйте расстояние Евкли-да.
Элементы маски формируются по формуле
Mask[i, j] = (maxDist - Dist[i, j]) / maxDist, где maxDist=√8
Разработайте программу, обеспечивающую загрузку изображения image0.jpg и применение фильтра с полученным ядром
Выполните отображение исходного и результирующего изображений.
При реализации используйте функцию filter2D.

3.	Фильтрация изображения с помощью линейного арифметического одно-родного усредняющего фильтра (функция boxFilter) и фильтра Гаусса (функция GaussianBlur)
Разработайте программу, обеспечивающую загрузку изображения image0.jpg и применение фильтров с вещественным ядром 5х5.
Для boxFilter выполнить для 2-х значений параметра normalize.
Выполнить отображение исходного и результирующего изображений
При реализации используйте функции

`boxFilter(src, ddepth, ksize[, dst[, anchor[, normalize[, borderType]]]]) -> dst`

Параметры:

    src - входное изображение.
    dst - целевое изображение того же размера, что и src.
    ddepth - задает глубину выходного изображения; –1 означает, что нуж-но использовать такую же глубину, как у входного
    ksize - размер ядра.
    anchor - определяет положение так называемого якорного пикселя. По умолчанию значение (–1, –1) означает, что якорь находится в центре ядра
    normalize - если normalize=True, то каждый выходной пиксель вычисля-ется как среднее арифметическое соседей с коэффициентами ядра 1/n, где n – число соседей. Если normalize=False, то все коэффициенты равны 1.
    default = True
    borderType - определяет поведение на краях изображения. default = BORDER_DEFAULT= gfedcb|abcdefgh|gfedcba

`GaussianBlur(src, ksize, sigmaX[, dst[,sigmaY[,borderType]]]) -> dst`

Параметры:
    

    src - входное изображение.
    dst - целевое изображение того же размера, что и src.
    ksize - размер ядра по Гауссу. ksize.width и ksize.height могут различать-ся, но оба они должны быть положительными и нечетными. 
    sigmaX - стандартное отклонение ядра Гаусса в направлении X (сигма нормального распределения в направлении X); если sigmaX=0, то стан-дартные отклонения вычисляются исходя из размера ядра
    sigmaY - стандартное отклонение ядра Гаусса в направлении Y; если sigmaY =0, он устанавливается равным sigmaX;
    borderType - определяет поведение на краях изображения. default = BORDER_DEFAULT = gfedcb|abcdefgh|gfedcba

4.	Фильтрация изображения с помощью нелинейных медианного (функция medianBlur) и двунаправленного фильтров (функция bilateralFilter)
Разработайте программу, обеспечивающую загрузку изображения image0.jpg и применение фильтров 
- медианного с линейным размером апертуры 5
  - двустороннего с sigmaColor=10, sigmaSpace=5.
  Выполнить отображение исходного и результирующего изображений
  При реализации используйте функции
  `medianBlur(src, ksize[,dst]) -> dst`
  Параметры:
  - src - входное изображение. 
  - dst - целевое изображение того же размера, что и src. 
  - ksize - линейный размер апертуры (ядра); он должен быть нечетным и больше единицы, например: 3, 5, 7.

`bilateralFilter(src, d, sigmaColor, sigmaSpace[, dst[, borderType]]) -> dst`
Параметры:
    src - входное изображение. 
    dst - целевое изображение того же размера, что и src.   
    d − диаметр окрестности пикселя. Если не задавать d явно, а поло-жить равным –1, то функция автоматически вычислит значение,
исходя из sigmaSpace.
    sigmaColor − определяет одномерное гауссово распределение, которое определяет степень допустимости различий в интенсивности пикселей.
    sigmaSpace − определяет пространственную протяженность ядра как в направлении x, так и в направлении y ( как фильтр Гаусса). Малые зна-чения sigmaSpace (10) дают слабый, но заметный эффект, а большие (150) – очень сильный эффект, но изображение приобретает «мультяшный» вид.
    borderType - определяет поведение на краях изображения. default = BORDER_DEFAULT = gfedcb|abcdefgh|gfedcba

5.	Фильтрация изображения с помощью фильтров повышения резкости
Разработать программу, обеспечивающую загрузку изображения cat.jpg и применение фильтров Превитта, Собеля, Шарра, Лапласса и модифици-рованного фильтра Лапласса для повышения резкости.
Выполнить отображение исходного и результирующего изображений
При реализации используйте функции
filter2D для реализации фильтра Превитта и модифицированного фильтра Лапласса

Sobel(src, ddepth, dx, dy[, dst[, ksize[, scale[, del-ta[, borderType]]]]]) -> dst
Параметры:
    src - входное изображение.
    dst - выходное изображение того же размера, что и src.
    ddepth -   глубина выходного изображения;
    dx - порядок производной в направлении x; обычно 1 или 0
    dy - порядок производной в направлении y; обычно 1 или 0
    ksize - размер ядра Собела: 1,3,5,7; default = 3
    scale - необязательный масштабирующий коэффициент; default = 1
    delta - необязательное значение, прибавляемое к результирующим пикселям перед сохранением в dst; default = 0
    borderType - определяет поведение на краях изображения; default = BORDER_DEFAULT
В случае ksize=FILTER_SCHARR оператор Собела = оператор Шарра 

Scharr(src, ddepth, dx, dy[, dst[, scale[, delta[, bor-derType]]]]) -> dst
Параметры:
    src - входное изображение.
    dst - выходное изображение того же размера, что и src.
    ddepth -   глубина выходного изображения;
    dx - порядок производной в направлении x; обычно 1 или 0
    dy - порядок производной в направлении y; обычно 1 или 0
   scale - необязательный масштабирующий коэффициент; default = 1
    delta - необязательное значение, прибавляемое к результирующим пикселям перед сохранением в dst; default = 0
    borderType - определяет поведение на краях изображения ; default = BORDER_DEFAULT
В операторе Шарра размер ядра всегда =3

Laplacian(src, ddepth[, dst[, ksize[, scale[, delta[, borderType]]]]]) -> dst
Параметры:
 src - исходное изображение.
 dst - целевое изображение того же размера, что и src.
 ddepth - желаемая глубина конечного изображения (–1 означает, что нужно использовать такую же глубину, как у входного).
 ksize - размер апертуры, используемый для вычисления фильтров 2-ой производной, является положительным четным числом. (по умолчанию ksize =1 и применяется апертура размером 3x3 и используется маска, изо-тропная для поворотов на углы, кратные pi/2) .
scale - необязательный масштабирующий коэффициент; default = 1 
delta - необязательное значение, прибавляемое к результирующим пиксе-лям перед сохранением в dst; default = 0
 borderType - определяет поведение на краях изображения; default = BORDER_DEFAULT
